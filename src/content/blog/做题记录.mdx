---
title: 做题记录
description: No Desc.
pubDate: 2025-10-10
categories:
    - 算法学习笔记
tags:
    - OI
    - 做题记录
---

import Collapse from "../../components/mdx/Collapse.astro";

### 10.9

#### Luogu P12195 [NOISG 2025 Prelim] Itinerary

关键在于发现按 $s$ 的次序依次走是最优的，并且能够想到通过维护路径经过次数来判断合不合法还有不同的起点只有 $u \to s _ 1$ 这一段的差异。想到这些就能自然而然的想到树剖了。

还是思维的锅啊，一直往子序列靠没往路径经过次数。

#### AtCoder ABC250E Prefix Equality

哈希不要用和哈希这种容易被卡的，用类 $Base$ 进制数或者异或哈希。

还有就是比较长的代码或者纯模拟，注意细节与理清思路，不要没想好就开写导致调的时间大于重构时间。

### 10.10

#### LibreOJ 2833 「JOISC 2018 Day 1」帐篷

思维灵活一点，限制放宽，不需要确定每一行的存在情况。

我们发现同一行与同一列不能同时放两个以上的帐篷，同时不能在同行与同列交点处有帐篷，我们就可以考虑对这个状态进行刻画。

记 $dp _ {i,j}$ 表示考虑了 $i$ 行 $j$ 列的方案数，则对于第 $i$ 行，我们分为以下四种情况考虑：

- 一个都不放：$dp _ {i,j} = dp _ {i,j}$。
- 放且不同行也不同列：则有 $4j$ 种选择（四种状态和 $j$ 列可选），有一行与一列正在决定，从 $dp _ {i - 1,j - 1}$ 转移来。
- 和之前一个放同列不同行： 之前的帐篷可选 $i - 1$ 行，自己可以选 $j$ 列，有两行一列正在决定，从 $dp _ {i - 2,j - 1}$ 转移来。
- 和之前一个放同行不同列： 在 $j$ 个空位中选两个，即 $C _ {j} ^ 2 = \frac{j(j - 1)}{2}$，有两列一行正在决定，从 $dp _ {i - 1,j - 2}$ 转移来。

所以，总的 DP 方程就是 $dp _ {i,j} = dp _ {i - 1,j} + 4j \cdot dp _ {i - 1,j - 1} + (i - 1)j \cdot dp _ {i - 2,j - 1} + \frac{j(j - 1)}{2} \cdot dp _ {i - 1,j - 2}$。

初始状态是 $dp _ {0,j} = dp _ {i,0} = 1$。

#### AtCoder ABC251D At Most 3 (Contestant ver.)

很有意思的一道构造题。

发现 $W \in [1,10 ^ 6]$ 而砝码只有 $300$ 个，所以我们需要一个高度压缩的方式表示出所有正整数。

我们发现，十进制下任意 $\lt 10 ^ 6$ 的正整数都可以被写成 $\overline{abcdef}$ 的形式。

考虑用百进制来表示出来这个数，发现只需要表示出 $\{x \mid x = 100 ^ 2 \times y,y \in [1,99] \cap \Z\} \cap \{x \mid x = 100 \times y,y \in [1,99] \cap \Z\} \cap \{x \mid x = 100 ^ 2 \times y,y \in [1,99] \cap \Z\}$ 就可以出所有的 $x \in [1,10 ^ 6) \cap \Z$。

上述一共有 $99 \times 3 = 297$ 个砝码，再加上 $10 ^ 6$ 本身只需要 $298$ 个砝码，可以通过。

心得：关于数的构造题不一定要从纯数论角度，也可以通过数的构成来构造。

### 10.11

#### A 询问

发现这个 $2a - i$ 和 $2b - i$ 的增长率显然大于 $a + i$ 和 $b + i$ 的增长率，所以大胆猜测经过足够多的次数后选取的全是 $2a - i$ 与 $2b - i$。

所以可以暴力预处理前 $30$ 次操作，因为 $a,b \in [0,10 ^ 9 + 7)$ 所以再大就爆 ```long long``` 了，然后后面用矩阵快速幂转移。

<Collapse title = "矩阵快速幂细节">

我们发现需要一个自增的变量，所以维护的矩阵是 $\begin{bmatrix} a _ i & b _ i & p _ i & 1 \end{bmatrix}$。转移是 $\begin{bmatrix} a _ i & b _ i & p _ i & 1 \end{bmatrix} \Rightarrow \begin{bmatrix} 2 b _ i - i & 2 a _ i - i & p _ i + 1 & 1 \end{bmatrix}$，所以转移矩阵为 $\begin{bmatrix} 2 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 \\ -1 & -1 & 1 & 0 \\ 0 & 0 & 1 & 1 \end{bmatrix}$。

</Collapse>

#### B k-绍兴序列

正问题不好做，我们考虑取约束条件的否命题，即 $\neg (\exist i \lt j,a _ i \lt k a _ j) = \forall i \lt j,a _ i \ge k a _ j$，则答案就是 $(m + 1) ^ n - Ans$。接下来分情况讨论：

- $k = 1$：等价于问有多少个值域为 $[0,m]$，长度为 $n$ 的单调不升序列。我们考虑插板法，则原问题等价于有 $n$ 个 $1$，放入 $m$ 块隔板的方案数，就等价于有 $n + m$ 个空位，放入 $n$ 个 $1$ 与 $m$ 个隔板的方案数，等于 $C _ {n + m} ^ n$。
- $k \ge 2$：我们发现有值的位置很少，所以我们就可以把值放进状态里做 DP，设 $dp _ {i,x}$ 表示第 $i$ 个位置是 $x$ 的方案数，则转移为 $dp _ {i,x} = \sum \limits _ {y = kx} ^ {n} dp _ {i - 1,y}$，初始状态为 $dp _ {1,[0,m]} = 1$。发现 $dp$ 中很多位置都是 $0$，于是我们可以维护一个上界等于 $\lfloor \frac{m}{k ^ {i - 1}} \rfloor$，然后用前缀和优化。答案就是 $\sum \limits _ {i = 0} ^ {\lfloor \frac{m}{k ^ {n - 1}} \rfloor} dp _ {n,i}$。

#### C 二次根式

显然 $G = \frac{N!}{F}$，所以我们只考虑求 $F$。

考虑对每个平方因子求有多少个数有这个因子，我们枚举质数，然后计算含有这个质数的所有倍数的平方的数的个数之和，所以 $F = \prod \limits _ {p \le \sqrt{N},p \in \text{Prime}} p ^ {\sum \limits _ {k = 1} \lfloor \frac{N}{p ^ {2k}} \rfloor}$。

线性筛预处理出 $[1,\sqrt{10 ^ 9 + 7}]$ 内的所有质数，这部分的复杂度是 $\Omicron(\frac{\sqrt{N}}{ \ln N} \times \log N) = \Omicron(\sqrt{n})$。

现在问题是如何快速求出 $N !$，快速阶乘我写不来，巧了，出题人也写不来。因为模数固定，所以考虑分块打表，设 $B = 3 \times 10 ^ 5$，用打表程序算出 $B!,(2B)!\dots$，然后主程序查表，多出来的部分暴力计算，时间复杂度是 $\Omicron(B)$，打完程序是 $33.8\text{kB}$，能过。

### 10.12

打 CF，[汇总链接](https://www.cnblogs.com/xguagua/p/19137920)。

### 10.13

#### AtCoder ABC250G Stonks

第一次见这种题。

我们先考虑一个贪心，如果 $i \lt j$ 且 $a _ i \lt a _ j$，则在第 $i$ 天买入，在第 $j$ 天卖出。

这玩意显然不对，因为后面可能会有更高的价格，于是我们考虑带上反悔操作，如果 $a _ i \lt a _ k$ 则在第 $i$ 天买入在第 $k$ 天卖出，后面如果有 $a _ k \lt a _ j$ 我们可以视为则在第 $k$ 天买入在第 $j$ 天卖出，总的来看是在第 $i$ 天买入在第 $j$ 天卖出。

实现上，我们维护一个小根堆，对于 $a _ i$，我们看堆顶 $a _ j$ 是否小于 $a _ i$，是的话，就将答案加上 $a _ i - a _ j$，并且删除 $a _ j$ 加入 $a _ i$。注意，后面不管成没成功加入都再将 $a _ i$ 加入一遍，因为一个是代表反悔操作，一个是代表直接购入。

### 10.14

#### A Happy·Lovely·Everyday！

我们发现 $\operatorname{popcount}(x \oplus y) = x \oplus y$，并且异或有结合律，于是题面就等价于将原序列分为若干段，对每段求异或和后的本质不同子序列个数。

而这个分段可以想到前缀的差分，我们设 $s _ i = \bigoplus _ {j = 1} ^ {i} a _ i$，则一个序列 $\{b _ i\}$ 合法的条件是存在一个序列 $p$，满足 $p _ 0 = 0,p _ k = n$ 且 $\forall i,b _ i = a _ {p _ i} \oplus a _ {p _ {i - 1}}$。

我们再对 $b$ 进行异或前缀和，设为 $B$，因为各个 $b$ 本质不同，所以一个 $B$ 唯一对应一个 $b$，所以原问题等价于求 $a _ {[1,n - 1]}$ 的本质不同子序列个数。

我们设 $dp _ {i}$ 表示以 $i$ 结尾的本质不同的子序列个数，如果前面没有和 $a _ i$ 相同的值，则 $dp _ {i} = 2 dp _ {i - 1} + 1$，因为包含之前的值和添加 $a _ i$ 后的值。

如果前面有与 $a _ i$ 相同的值，记 $last$ 为之前出现的位置，则 $dp _ {i} = 2 dp _ {i - 1} - dp _ {last - 1}$，因为 $[1,last - 1]$ 区间中的答案是与之前重复的，而这部分答案有 $dp _ {last - 1} + 1$ 个。

最终答案是 $dp _ {n - 1}$，初始状态为 $dp _ 1 = 1$。

#### B 敬启，致那时的我

显然斐波那契数列没有什么好的性质，而看到斐波那契数列你应该能想到这是递推，而想到递推就能想到矩阵快速幂。

设转移矩阵为 $B$，则我们对应每一位的维护 $P _ k = B ^ {2 ^ k},k \in [0,n)$，我们先思考限制弱一些的特殊性质 C，发现就等价于从 $P$ 中选择 $k$ 个乘起来再左乘初始矩阵的答案之和。

因为矩阵乘法有分配律，所以可以记录和，最后一起左乘初始矩阵。考虑 DP，设 $dp _ {i,j}$ 表示考虑从小到大前 $i$ 个矩阵，选择了 $j$ 个的矩阵积的和矩阵。则有 $dp _ {0,0} = I$，转移就是考虑第 $i$ 个选或者不选，$dp _ {i,j} = dp _ {i - 1,j} + dp _ {i - 1,j - 1} \times P _ {i - 1}$。

然后考虑一般情况，这个时候就有数位限制了。我们参考迭代实现的数位 DP 统计答案的方式，枚举这一位是否达到上限。

我们用递归实现，设 $f _ {n,k}$ 表示还剩 $n$ 个数，$k$ 个位置可以选的有数位限制的矩阵积之和，分情况讨论：

- $s _ {n} = 1$，这种情况 $0$ 或 $1$ 都可以选，$0$ 后面是没有限制的，所以是 $dp _ {n - 1,k}$，而 $1$ 的情况有限制，所以是 $f _ {n - 1,k - 1} \times P _ {n - 1}$。
- $s _ {n} = 0$，这种情况有限制，所以是 $f _ {n - 1,k}$。

到最底层判断一下 $k$ 是否等于 $0$，如果不等于 $0$ 说明不合法，返回 $O$，否则返回 $I$。

### 10.15

#### A 火

鉴定为学矩阵和学线段树学魔怔了。

我们对每个位置分别考虑被选到的概率，加起来就是总期望。

一棵树燃烧，当且仅当 $[\max \{1,i - k\},\min \{n,i + k\}]$ 中有至少一棵燃着的树。我们对每棵树分别考虑概率。第 $i$ 棵树被第 $i - k$ 棵点燃的概率是 $p _ {i - k}$，如果没有点燃，考虑下一棵树，则被第 $i - k + 1$ 棵树点燃的概率为 $(1 - p _ {i - k})p _ {i - k + 1}$，以此类推。

直接做是 $\Omicron(nk)$ 的，考虑优化。发现这个式子其实是个线性递推，则我们维护 $\begin{bmatrix} sum & prod \end{bmatrix}$，转移是 $\begin{bmatrix} sum & prod \end{bmatrix} \Rightarrow \begin{bmatrix} sum + prod \times p _ i & prod \times (1 - p _ i) \end{bmatrix}$，则我们对每个位置维护一个转移矩阵 $\begin{bmatrix} 1 & 0 \\ p _ i & 1 - p _ i \end{bmatrix}$，用线段树区间查询就能做到 $\Omicron(n \log k)$。

#### B 捐赠

先考虑一个双 $\log$ 的解法。

我们发现取的一定是能做正贡献的，所以我们选取的是所有 $a _ i + b _ i \ge 0$ 的 $i$。所以我们可以二分一个 $k$ 表示 $k$ 及之前都可以取，则判断条件就是 $a$ 的第 $k$ 大值与 $b$ 的第 $k$ 大值之和是否大于 $0$。求出来 $k$ 之后答案就是 $a$ 的前 $k$ 大值与 $b$ 的前 $k$ 大值之和。上述操作都可以用权值线段树维护。~~然后你就能发现你过了，卡不掉你。~~

还是写一下单 $\log$ 做法。因为 $a$ 与 $b$ 被选取的数量是一样的，所以 $a$ 被选取的数量加上 $b$ 没被选取的数量是和 $b$ 的大小相等的。所以 $b$ 的贡献等于 $b$ 的所有元素之和减去未被选取的元素。

于是我们只用一棵权值线段树，存储 $a$ 的所有值与 $b$ 的所有相反值。查询取前 $\text{num}(b)$ 个，然后加上 $b$ 的和。

#### C 染色

考虑一个 $\Omicron(n ^ 2)$ 的树形 DP。考虑一棵子树，染完色之后要么没有染色的需要的颜色是同一种，要么全部已经染完色。

设 $dp _ {u,i}$ 表示以 $u$ 为根的子树，需要染的颜色是 $i$，$i = 0$ 表示不需要染色。则 $\forall i \in [1,n],dp _ {u,i} = \prod \limits _ {v \in \text{Son}(u)} (dp _ {v,0} + dp _ {v,i}) - \prod \limits _ {v \in \text{Son}(u)} dp _ {v,0}$，表示 $v$ 可以被染完也可以需求 $i$ 颜色，最后减去全部染完色的方案。

对于 $i = 0$，有 $dp _ {u,0} = (m + 1) \prod \limits _ {v \in \text{Son}(u)} dp _ {v,0} + \sum \limits _ {i = 1} ^ m dp _ {u,i}$，表示子节点全部染完色，$u$ 颜色任意，后面表示将需求为 $i$ 的 $u$ 从无色变为 $i$。

直接做是 $\Omicron(n ^ 2)$ 的，考虑优化，我们可以用线段树合并做到 $\Omicron(n \log n)$。

<p style = "display: none;">为什么被卡空间了啊艹</p>

### 10.16

#### A 玩具

第一遍还没读懂题意说是（

题意就是从区间 $[l _ i,r _ i]$ 中选择一个子区间，如果其和可以被 $k _ i$ 整除则给答案加上 $w _ i$，否则减去。

一个区间可以被表示为两个前缀和之差，所以和可以被 $k _ i$ 整除等价于两前缀和同余。观察数据发现 $k _ i$ 不大，可以从这方面入手。

我们发现，一个长为 $len$ 的区间最多有 $len + 1$ 种不同的前缀和，所以当 $r _ i - l _ i + 1 \gt \max \{k _ i\}$ 时一定存在解，小于 $\max \{k _ i\}$ 的最多只有 $99$，暴力即可。

#### C 文件

神奇东西，用的二维链表。

先写一下二维链表是什么，就是每个结点的指针指向它右边的结点与下面的结点，双向就是加上左边和上面的。

然后回到这道题上来，我们先想一下交换一个序列不交的两个区间的做法，可以用链表，将每段前一个元素的指针交换，再将每段最后一个元素的指针交换。

扩展到二维，我们需要交换矩形的四个边界的指针，找到之后直接交换就行了。

### 10.17

#### A 并非贪心

我们发现这个 $\prod \limits _ {i \in S} a _ i$ 十分不好维护，考虑随便选个底数取个对数，这样就只用维护和了，假设我们取的是 $e$。那么原式等于 $\sqrt[\sum \limits _ {i \in S} b _ i]{\prod \limits _ {i \in S}\exp(\ln a _ i)} = \sqrt[\sum \limits _ {i \in S} b _ i]{\exp(\sum \limits _ {i \in S} \ln a _ i)} = \exp(\frac{\sum \limits _ {i \in S}{\ln a _ i}}{\sum \limits _ {i \in S} b _ i})$。又发现这个 $\sum b _ i$ 不大，所以可以考虑直接做 0/1 背包。

还是太糖了，典中典 Trick 没想到。

#### C 斐波那契

这个故事告诉我们 Trick 不要乱用，套几天前的 Trick 做出来个没有前途的做法，其实正解非常糖。

以下记 $f _ i$ 表示斐波那契数列的第 $i$ 项。

首先有个结论： $\gcd(f _ i,f _ j) = f _ {\gcd(i,j)}$。

然后我们开始推推推推推式子：

$$
\begin{aligned}
\sum _ {i = 1} ^ n \sum _ {j = 1} ^ n \gcd(f _ i,f _ j) &= \sum _ {i = 1} ^ n \sum _ {j = 1} ^ n f _ {\gcd(i,j)} \\
&= \sum _ {d = 1} f _ {d} \sum _ {i = 1} ^ n \sum _ {j = 1} ^ n [\gcd(i,j) = d]\\
&= \sum _ {d = 1} f _ {d} \sum _ {i = 1} ^ {\lfloor \frac{n}{d} \rfloor} \sum _ {j = 1} ^ {\lfloor \frac{n}{d} \rfloor} [\gcd(i,j) = 1]\\
\end{aligned}
$$

考虑每个元素的贡献，一个数会在 $i \le j$ 时在 $\varphi(j)$ 中贡献，在 $i \gt j$ 时在 $\varphi(i)$ 中贡献，所以每个 $\varphi(i)$ 会贡献两次，但是 $n$ 不会，所以后面那部分的总贡献是 $(2\sum \limits _ {i = 1} ^ {\lfloor \frac{n}{d} \rfloor} \varphi(i)) - 1$。

观察到 $n \le 10 ^ {10}$，考虑杜教筛。然后 $d$ 的部分整除分块，$f _ {d}$ 的前缀和可以用矩阵快速幂算出来。

### 10.18

#### [A 路径(ABC335E)](https://www.luogu.com.cn/problem/AT_abc335_e)

发现只有 $a _ u \le a _ v$ 的边才有用，所以我们可以只加这些边来跑最长路。

但是有个问题，当 $a _ u = a _ v$ 时会出现环导致我们不能跑拓扑。~~什么你说 SPFA？亲测被卡了。~~

又发现，当 $a _ u = a _ v$ 时，我们加的边的边权都是 $0$，对答案没有贡献，于是我们可以把所有用边权为 $0$ 的边连接的点全部缩起来，这样原图就成了一个 DAG，可以直接跑拓扑排序。

缩点不用写 Tarjan，用并查集合并起来就行。

#### [B 队列(ARC090B)](https://www.luogu.com.cn/problem/AT_arc090_b)

一个等于的限制可以用两个不等于的限制来刻画，所以原限制等价于 $\begin{cases} x _ v \le x _ u + w \\ x _ v \ge x _ u + w \end{cases} \Rightarrow \begin{cases} x _ v \le x _ u + w \\ x _ u \le x _ v - w \end{cases}$。连边 $u \xrightarrow{w}v,v \xrightarrow{-w} u$ 后跑差分约束。

但是裸的 SPFA 被卡了，于是我们可以用 DFS SPFA，这样就能卡过去了。

#### [C 计数(ABC284G)](https://www.luogu.com.cn/problem/AT_abc284_g)

发现只能一条路走到底，而走到环就出不去了，所以至多有 $1$ 个环，而这个图有 $n$ 个点 $n$ 条边，所以一个联通块有且仅有一个环。

我们设 $B _ {i,l + 1}$ 与 $B _ {i,p}$ 开始重复，则贡献显然是 $p - 1$。

所以一条长度为 $l$ 的到环上的链的贡献是 $A _ {n - 1} ^ {l - 1} n ^ {n - l} \frac{l(l - 1)}{2}$，其中 $A _ {n - 1} ^ {l - 1}$ 表示除去起点后选择 $l - 1$ 个点，$n ^ {n - l}$ 表示其余的所有点无限制的方案数，后面的是 $\sum \limits _ {i = 1} ^ l (i - 1)$ 用等差数列算出来的，表示链上每个点作为起点的贡献。

#### [D 游泳(Luogu P4182)](https://www.luogu.com.cn/problem/P4182)

正解是单调队列优化 DP，但是我就要写歪解（

发现有个恰好 $k$ 个的限制，考虑 WQS 二分。

我们把删去 $k$ 个转化为保留 $n - k$ 个，设 $f(x)$ 表示保留 $k$ 个的答案，发现这个 $f$ 是凸的。

于是我们二分惩罚 $p$，然后用 DP 去检查。离散化端点，并且按左端点排序。设 $dp _ i$ 表示考虑前 $i$ 个的并集最大值，强制选 $i$。则转移如下：

- 若 $l _ i \gt r _ j$，则有 $dp _ i = \max \{dp _ j\} + r _ i - l _ i - p$
- 若 $r _ j \in [l _ i,r _ i]$，则有 $dp _ i = \max \{dp _ j - r _ j\} + r _ i - p$

第一个可以用树状数组维护，算完 $dp _ i$ 的值之后更新 $r _ i$ 的值；第二个可以用线段树维护，然后就能做到 $\Omicron(n \log n \log V)$。

略微卡常，我们可以使用 ZKW 线段树来卡常，就能过了。

### 10.20

#### CF Round 1060

[Link](https://www.cnblogs.com/xguagua/p/19152363)