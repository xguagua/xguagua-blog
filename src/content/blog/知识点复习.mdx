---
title: 知识点复习
description: CSP J/S & NOIP
pubDate: 2025-10-24
categories:
    - 算法学习笔记
tags:
    - OI
---

import Error from "../../components/mdx/Error.astro";
import Warning from "../../components/mdx/Warning.astro";
import Success from "../../components/mdx/Success.astro";
import Collapse from "../../components/mdx/Collapse.astro"

因为在做题的时候发现有些知识点连板子都不会敲了就整理了个这个。

```Error``` 表示重要的没干，```Warning``` 表示不那么重要的没干。

做完的就把 ```Error``` 改成 ```Success```，下面接个板子和不熟的地方。

除了下面的还有思维，下面的数据结构与图论结构等还有（优化）DP。

## 基本能力

<Error>中大型模拟</Error>

<Error>打表、猜结论</Error>

## 基础算法

<Error>分治：普通分治，猫树分治，CDQ分治</Error>

## 图论

<Success>Tarjan：强连通分量，点双连通分量 & 割点，边双连通分量 & 割边，圆方树</Success>

<Collapse title = "总结">

这个东西就是把一般图转为 DAG / 树，重点还是处理树上问题或者 DAG 上问题。

圆方树就是将一般图转为树，然后就能套一堆恶心的东西了，应该不会考吧。

</Collapse>

<Success>点分治</Success>

<Collapse title = "总结">

看到树上路径问题可以往点分治考虑。

记得怎么划分就行，相信你的 DS 能力。

记得卡点常，常数比较大。

</Collapse>

<Success>基环树</Success>

<Collapse title = "总结">

可以考虑断环成链，也可以考虑分别计算后合并。

如果出 DS 类就分别考虑环和树，实在不行当成仙人掌做圆方树。

</Collapse>

<Success>网络流</Success>

<Collapse title = "总结">

关键是建图，建完图都好说。

有对点的限制直接拆点，如果有做过的模型比如棋盘最大值和 DAG 最小路径覆盖就直接套。

</Collapse>

<Success>最小生成树：魔改的 Kruskal,Prim,Boruvka</Success>

<Collapse title = "总结">

前两个不好变式，难点就是 Boruvka 怎么快速维护最小边。

</Collapse>

<Error>最短路：同余最短路（转圈与同余背包）</Error>

<Collapse title = "总结">

只求最短路不到万不得已不写 SPFA，必须写就加上优化。

同余最短路不会转圈也不用勉强，余数记得取几个里面最小的就行。

</Collapse>

<Error>各种优化建图</Error>

<Error>启发式合并，各种树链剖分优化 DP</Error>

## 数据结构

<Success>01-Trie 的各种操作与可持久化</Success>

<Collapse title = "总结">

记住维护异或极值建高位 Trie，就是将一个二进制数从高到低视作一个字符串。

维护异或和建低位 Trie，这样就能理解为什么要那样 ```pushup``` 了。

合并就是给每个结点的所有信息合并起来。

可持久化参考线段树。

</Collapse>

<Error>线性基</Error>

<Success>可并堆</Success>

<Collapse title = "总结">

应该考不到，纯堆需要合并就用 ```__gnu_pbds::priority_queue```。

然后会了板子加上会打 ```lazytag``` 就行。

记得找根结点要用并查集不然容易被卡。

</Collapse>

### 基础数据结构

<Error>链表的各种奇技淫巧</Error>

<Error>单调队列，单调栈</Error>

<Error>lxl ST表</Error>

### 线段树

<Success>树套树</Success>

<Collapse title = "总结">

没什么说的，暴力战斗爽，注意卡常。

</Collapse>

<Success>线段树合并 & 优化 DP（类似 Minimax）</Success>

<Collapse title = "总结">

在叶子结点合并信息，可以直接合并的也可以直接算。

优化 DP 的特征就是树上需要多次合并，并且每个结点的是一个数组，可能和前缀这些有关。

</Collapse>

<Success>线段树二分，主席树与其各种操作</Success>

<Collapse title = "总结">

这种东西还是因题而异吧，知道怎么维护就行。

主席树就记住一般是维护前缀线段树的信息的。

</Collapse>

### 树状数组

<Error>树状数组二分</Error>

### BST & 平衡树

> 你不要写你那「CENSORED」的平衡树了

<Success>FHQ Treap（$\Omicron(n)$ 建树）</Success>

<Collapse title = "总结">

会写板子就行，$\Omicron(n)$ 建树可以参考笛卡尔树或者线段树，线段树的好写一点。

</Collapse>

<Success>笛卡尔树</Success>

<Collapse title = "总结">

感觉就是给单调栈附加了位置信息与树形结构，主要就是要会 $\Omicron(n)$ 建树。

$\Omicron(n)$ 建树的重点就是记住用单调栈去维护右链，然后用笛卡尔树的定义来推。

在最值上有些用，比如区间 $[l,r]$ 的最值就是笛卡尔树上 $l,r$ 的 LCA。

</Collapse>

### 根号一家子

<Success>序列分块、根号分治</Success>

<Collapse title = "总结">

这个主要就是看 $\log$ 类结构是不是维护不了，然后就看分块后能不能做到一个可接受的复杂度，以及整块信息能不能很好的下放与维护。

本质上就是为了平衡复杂度而生的东西。

</Collapse>

<Warning>各种莫队</Warning>

## DP

> 最优子结构 无后效性 子问题重叠

> 一般 DP 本质是 DFA，从决策的角度思考转移

> 别慌

<Error>数位 DP 与其扩展</Error>

<Error>换根 DP</Error>

<Warning>DDP</Warning>

<Warning>DP 套 DP</Warning>

### 背包 DP

> 等价于卷积 ：$(\min,+) / (+,\times)$

<Error>树上背包</Error>

<Error>带统计方案的背包</Error>

### DP 优化

> 注意观察性质，一般从区间转移考虑线段树，最优化 DP 转移式子与 $i,j$ 同时相关考虑斜率优化，否则考虑单调队列

<Error>倍增优化 DP</Error>

<Error>单调队列优化 DP</Error>

<Error>斜率优化 DP</Error>

## 字符串

<Error>KMP</Error>

<Error>AC 自动机与 ACAM DP</Error>

<Error>Manacher</Error>

<Error>子序列自动机与应用</Error>

## 数学

<Success>卡特兰数</Success>

<Collapse title = "总结">

记住那些模型和递推式，以及前几项是什么就行。

</Collapse>

<Error>分拆数</Error>

<Error>莫比乌斯反演与二项式反演</Error>

<Error>高斯消元法</Error>

<Error>欧拉函数等</Error>

<Error>线性筛，同余</Error>