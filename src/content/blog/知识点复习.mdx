---
title: 知识点复习
description: CSP J/S & NOIP
pubDate: 2025-10-24
categories:
    - 算法学习笔记
tags:
    - OI
---

import Error from "../../components/mdx/Error.astro";
import Warning from "../../components/mdx/Warning.astro";
import Success from "../../components/mdx/Success.astro";
import Collapse from "../../components/mdx/Collapse.astro"

因为在做题的时候发现有些知识点连板子都不会敲了就整理了个这个。

```Error``` 表示重要的没干，```Warning``` 表示不那么重要的没干。

做完的就把 ```Error``` 改成 ```Success```，下面接个板子和不熟的地方。

除了下面的还有思维，下面的数据结构与图论结构等还有（优化）DP。

## 基本能力

<Error>中大型模拟</Error>

<Error>打表、猜结论</Error>

## 基础算法

<Error>分治：普通分治，猫树分治，CDQ分治</Error>

## 图论

<Error>Tarjan：强连通分量，点双连通分量 & 割点，边双连通分量 & 割边，圆方树</Error>

<Error>点分治</Error>

<Error>网络流</Error>

<Error>最小生成树：魔改的 Kruskal,Prim,Boruvka</Error>

<Error>最短路：SPFA（DFS 实现与给 SSP 的实现），同余最短路（转圈与同余背包）</Error>

<Error>各种优化建图</Error>

<Error>启发式合并，各种树链剖分优化 DP</Error>

<Error>基环树</Error>

## 数据结构

<Success>01-Trie 的各种操作与可持久化</Success>

<Collapse title = "总结">

记住维护异或极值建高位 Trie，就是将一个二进制数从高到低视作一个字符串。

维护异或和建低位 Trie，这样就能理解为什么要那样 ```pushup``` 了。

合并就是给每个节点的所有信息合并起来。

可持久化参考线段树。

</Collapse>

<Error>线性基</Error>

<Success>可并堆</Success>

<Collapse title = "总结">

应该考不到，纯堆需要合并就用 ```__gnu_pbds::priority_queue```。

然后会了板子加上会打 ```lazytag``` 就行。

记得找根节点要用并查集不然容易被卡。

</Collapse>

### 基础数据结构

<Error>链表的各种奇技淫巧</Error>

<Error>单调队列，单调栈</Error>

<Error>lxl ST表</Error>

### 线段树

<Error>李超线段树，吉司机线段树，猫树</Error>

<Success>树套树</Success>

<Collapse title = "总结">

没什么说的，暴力战斗爽，注意卡常。

</Collapse>

<Error>线段树合并 & 优化 DP（类似 Minimax）</Error>

<Success>线段树二分，主席树与其各种操作</Success>

<Collapse title = "总结">

这种东西还是因题而异吧，知道怎么维护就行。

主席数就记住一般是维护前缀线段树的信息的。

</Collapse>

### 树状数组

<Error>树状数组二分</Error>

### BST & 平衡树

> 你不要写你那「CENSORED」的平衡树了

<Success>FHQ Treap（$\Omicron(n)$ 建树）</Success>

<Collapse title = "总结">

会写板子就行，$\Omicron(n)$ 建树可以参考笛卡尔树或者线段树，线段树的好写一点。

</Collapse>

<Success>笛卡尔树</Success>

<Collapse title = "总结">

感觉就是给单调栈附加了位置信息与树形结构，主要就是要会 $\Omicron(n)$ 建树。

$\Omicron(n)$ 建树的重点就是记住用单调栈去维护右链，然后用笛卡尔树的定义来推。

在最值上有些用，比如区间 $[l,r]$ 的最值就是笛卡尔树上 $l,r$ 的 LCA。

</Collapse>

### 根号一家子

<Success>序列分块、根号分治</Success>

<Collapse title = "总结">

这个主要就是看 $\log$ 类结构是不是维护不了，然后就看分块后能不能做到一个可接受的复杂度，以及整块信息能不能很好的下放与维护。

本质上就是为了平衡复杂度而生的东西。

</Collapse>

<Warning>各种莫队</Warning>

## DP

> 最优子结构 无后效性 子问题重叠

> 一般 DP 本质是 DFA，从决策的角度思考转移

> 别慌

<Error>数位 DP 与其扩展</Error>

<Error>换根 DP</Error>

<Warning>DDP</Warning>

<Warning>DP 套 DP</Warning>

### 背包 DP

> 等价于卷积 ：$(\min,+) / (+,\times)$

<Error>树上背包</Error>

<Error>带统计方案的背包</Error>

### DP 优化

> 注意观察性质，一般从区间转移考虑线段树，最优化 DP 转移式子与 $i,j$ 同时相关考虑斜率优化，否则考虑单调队列

<Error>倍增优化 DP</Error>

<Error>单调队列优化 DP</Error>

<Success>斜率优化 DP（并入李超线段树）</Success>

## 字符串

<Error>KMP</Error>

<Error>AC 自动机与 ACAM DP</Error>

<Error>Manacher</Error>

<Error>子序列自动机与应用</Error>

## 数学

<Success>卡特兰数</Success>

<Collapse title = "总结">

记住那些模型和递推式，以及前几项是什么就行。

</Collapse>

<Warning>普通生成函数与基础多项式算法（FFT、NTT、多项式求逆等）</Warning>

<Error>莫比乌斯反演与二项式反演</Error>

<Error>高斯消元法</Error>

<Error>欧拉函数等</Error>

<Error>线性筛，同余</Error>